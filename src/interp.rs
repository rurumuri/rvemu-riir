use core::panic;
use std::mem;

use crate::{
    decode::insn_decode,
    insn::{insn_t, insn_type_t},
    machine::{state_t, to_host_addr},
    reg::gp_reg_type_t,
};

type interp_func_t = fn(&state_t, &insn_t);

fn interp_func_empty(state: &state_t, insn: &insn_t) {
    panic!("Unhandled instruction type: {:?}", insn.type_);
}

static interp_funcs: [interp_func_t; insn_type_t::num_insns as usize] = [
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
    interp_func_empty,
];

pub fn exec_block_interp(state: &mut state_t) {
    loop {
        let mut insn: insn_t = unsafe { mem::zeroed() };
        let insn_data = unsafe { *(to_host_addr(state.pc) as *const u64) as u32 };
        insn_decode(&mut insn, insn_data);

        interp_funcs[insn.type_ as usize](state, &insn);

        state.gp_regs[gp_reg_type_t::zero as usize] = 0;

        if insn.cont {
            break;
        }

        state.pc += match insn.rvc {
            true => 2,
            false => 4,
        };
    }
}
